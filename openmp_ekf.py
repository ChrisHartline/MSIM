# -*- coding: utf-8 -*-
"""OpenMP_EKF.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1K1_zRps77fI5JbkMGJEDgvHrm6v8zdhx
"""

# ============================================================================
# Day 3: C++ EKF with OpenMP Parallelization
# MSIM815 Final Project - Multi-Sensor Parallel Processing
# ============================================================================

"""
PURPOSE: Implement EKF in C++ with OpenMP for multi-sensor processing
OUTPUTS:
  - C++ EKF implementation
  - OpenMP parallel processing
  - Speedup measurements
"""

# ============================================================================
# SETUP
# ============================================================================

from google.colab import drive
drive.mount('/content/drive')

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import os
import time
import subprocess

BASE_DIR = '/content/drive/MyDrive/MSIM815'
DATA_DIR = f'{BASE_DIR}/data/large_dataset'
RESULTS_DIR = f'{BASE_DIR}/results/day3'
CODE_DIR = '/content/ekf_cpp'

os.makedirs(RESULTS_DIR, exist_ok=True)
os.makedirs(CODE_DIR, exist_ok=True)

print("‚úÖ Setup complete")

# ============================================================================
# INSTALL DEPENDENCIES
# ============================================================================

print("\nüì¶ Installing dependencies...")

# Install Eigen library
!apt-get update -qq
!apt-get install -qq libeigen3-dev

# Verify OpenMP
!echo "#include <omp.h>" | g++ -fopenmp -x c++ - -o /tmp/test 2>&1 | grep -q "error" && echo "‚ùå OpenMP not available" || echo "‚úÖ OpenMP available"

print("‚úÖ Dependencies installed")

# ============================================================================
# C++ EKF IMPLEMENTATION
# ============================================================================

print("\nüìù Writing C++ EKF code...")

cpp_code = """
#include <Eigen/Dense>
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <chrono>
#include <omp.h>

using namespace Eigen;
using namespace std;
using namespace std::chrono;

class ExtendedKalmanFilter {
private:
    VectorXd x;     // State [x, y, z, vx, vy, vz]
    MatrixXd P;     // Covariance
    MatrixXd F;     // State transition
    MatrixXd Q;     // Process noise
    MatrixXd H;     // Measurement matrix
    MatrixXd R;     // Measurement noise
    double dt;

public:
    ExtendedKalmanFilter(double timestep = 0.01) : dt(timestep) {
        // Initialize state (6D)
        x = VectorXd::Zero(6);

        // Initialize covariance
        P = MatrixXd::Identity(6, 6) * 1.0;

        // State transition matrix (constant velocity)
        F = MatrixXd::Identity(6, 6);
        F(0, 3) = dt;
        F(1, 4) = dt;
        F(2, 5) = dt;

        // Process noise
        Q = MatrixXd::Identity(6, 6) * 0.01;

        // Measurement matrix (measure position only)
        H = MatrixXd::Zero(3, 6);
        H(0, 0) = 1.0;
        H(1, 1) = 1.0;
        H(2, 2) = 1.0;

        // Measurement noise
        R = MatrixXd::Zero(3, 3);
        R(0, 0) = 9.0;   // GPS x variance
        R(1, 1) = 9.0;   // GPS y variance
        R(2, 2) = 25.0;  // GPS z variance
    }

    void initialize(const Vector3d& initial_pos) {
        x.head<3>() = initial_pos;
        x.tail<3>().setZero();
    }

    void predict() {
        // State prediction
        x = F * x;

        // Covariance prediction
        P = F * P * F.transpose() + Q;
    }

    void update(const Vector3d& measurement) {
        // Innovation
        VectorXd y = measurement - H * x;

        // Innovation covariance
        MatrixXd S = H * P * H.transpose() + R;

        // Kalman gain
        MatrixXd K = P * H.transpose() * S.inverse();

        // State update
        x = x + K * y;

        // Covariance update
        MatrixXd I = MatrixXd::Identity(6, 6);
        P = (I - K * H) * P;
    }

    Vector3d getPosition() const {
        return x.head<3>();
    }

    Vector3d getVelocity() const {
        return x.tail<3>();
    }
};

// Load CSV data
vector<Vector3d> loadCSV(const string& filename) {
    vector<Vector3d> data;
    ifstream file(filename);
    string line, val;

    // Skip header
    getline(file, line);

    while (getline(file, line)) {
        stringstream ss(line);
        Vector3d point;

        getline(ss, val, ',');
        point(0) = stod(val);

        getline(ss, val, ',');
        point(1) = stod(val);

        getline(ss, val, ',');
        point(2) = stod(val);

        data.push_back(point);
    }

    return data;
}

// Save CSV data
void saveCSV(const string& filename, const vector<Vector3d>& data) {
    ofstream file(filename);
    file << "x,y,z\\n";

    for (const auto& point : data) {
        file << point(0) << "," << point(1) << "," << point(2) << "\\n";
    }
}

// Process single channel (sequential)
vector<Vector3d> processChannel(const vector<Vector3d>& measurements, double dt) {
    ExtendedKalmanFilter ekf(dt);
    ekf.initialize(measurements[0]);

    vector<Vector3d> outputs;
    outputs.reserve(measurements.size());

    for (size_t i = 0; i < measurements.size(); ++i) {
        ekf.predict();
        ekf.update(measurements[i]);
        outputs.push_back(ekf.getPosition());
    }

    return outputs;
}

int main(int argc, char** argv) {
    if (argc < 4) {
        cerr << "Usage: " << argv[0] << " <data_dir> <output_dir> <num_threads>" << endl;
        return 1;
    }

    string data_dir = argv[1];
    string output_dir = argv[2];
    int num_threads = stoi(argv[3]);

    double dt = 0.01;  // 100 Hz

    cout << "Loading data..." << endl;

    // Load 3 channels
    vector<Vector3d> channel1 = loadCSV(data_dir + "/channel_imu_15min.csv");
    vector<Vector3d> channel2 = loadCSV(data_dir + "/channel_gps_15min.csv");
    vector<Vector3d> channel3 = loadCSV(data_dir + "/channel_mag_15min.csv");

    cout << "Loaded " << channel1.size() << " samples per channel" << endl;

    // SEQUENTIAL PROCESSING
    cout << "\\n=== Sequential Processing ===" << endl;
    auto start_seq = high_resolution_clock::now();

    vector<Vector3d> output1_seq = processChannel(channel1, dt);
    vector<Vector3d> output2_seq = processChannel(channel2, dt);
    vector<Vector3d> output3_seq = processChannel(channel3, dt);

    auto end_seq = high_resolution_clock::now();
    auto duration_seq = duration_cast<milliseconds>(end_seq - start_seq);

    cout << "Sequential time: " << duration_seq.count() << " ms" << endl;

    // PARALLEL PROCESSING WITH OPENMP
    if (num_threads > 1) {
        cout << "\\n=== Parallel Processing (" << num_threads << " threads) ===" << endl;
        omp_set_num_threads(num_threads);

        vector<Vector3d> output1_par, output2_par, output3_par;

        auto start_par = high_resolution_clock::now();

        #pragma omp parallel sections
        {
            #pragma omp section
            {
                output1_par = processChannel(channel1, dt);
                cout << "Thread " << omp_get_thread_num() << " finished channel 1" << endl;
            }

            #pragma omp section
            {
                output2_par = processChannel(channel2, dt);
                cout << "Thread " << omp_get_thread_num() << " finished channel 2" << endl;
            }

            #pragma omp section
            {
                output3_par = processChannel(channel3, dt);
                cout << "Thread " << omp_get_thread_num() << " finished channel 3" << endl;
            }
        }

        auto end_par = high_resolution_clock::now();
        auto duration_par = duration_cast<milliseconds>(end_par - start_par);

        cout << "Parallel time: " << duration_par.count() << " ms" << endl;
        cout << "Speedup: " << (double)duration_seq.count() / duration_par.count() << "x" << endl;

        // Save parallel results
        saveCSV(output_dir + "/channel1_ekf.csv", output1_par);
        saveCSV(output_dir + "/channel2_ekf.csv", output2_par);
        saveCSV(output_dir + "/channel3_ekf.csv", output3_par);

        // Save timing
        ofstream timing_file(output_dir + "/timing.txt");
        timing_file << "sequential_ms," << duration_seq.count() << endl;
        timing_file << "parallel_ms," << duration_par.count() << endl;
        timing_file << "speedup," << (double)duration_seq.count() / duration_par.count() << endl;
        timing_file << "threads," << num_threads << endl;
        timing_file.close();
    } else {
        // Save sequential results
        saveCSV(output_dir + "/channel1_ekf.csv", output1_seq);
        saveCSV(output_dir + "/channel2_ekf.csv", output2_seq);
        saveCSV(output_dir + "/channel3_ekf.csv", output3_seq);
    }

    cout << "\\nResults saved to " << output_dir << endl;

    return 0;
}
"""

# Write C++ code to file
cpp_file = f'{CODE_DIR}/ekf_parallel.cpp'
with open(cpp_file, 'w') as f:
    f.write(cpp_code)

print(f"   ‚úÖ C++ code written: {cpp_file}")

# ============================================================================
# COMPILE C++ CODE
# ============================================================================

print("\nüî® Compiling C++ code...")

compile_cmd = f"g++ -O3 -fopenmp -I/usr/include/eigen3 {cpp_file} -o {CODE_DIR}/ekf_parallel"
result = subprocess.run(compile_cmd, shell=True, capture_output=True, text=True)

if result.returncode != 0:
    print("‚ùå Compilation failed:")
    print(result.stderr)
    raise Exception("Compilation failed")
else:
    print("‚úÖ Compilation successful")

# ============================================================================
# RUN C++ PROGRAM
# ============================================================================

print("\nüöÄ Running C++ EKF with OpenMP...")

# Run with 3 threads
run_cmd = f"{CODE_DIR}/ekf_parallel {DATA_DIR} {RESULTS_DIR} 3"
result = subprocess.run(run_cmd, shell=True, capture_output=True, text=True)

print(result.stdout)

if result.returncode != 0:
    print("‚ùå Execution failed:")
    print(result.stderr)
    raise Exception("Execution failed")

# ============================================================================
# LOAD AND ANALYZE RESULTS
# ============================================================================

print("\nüìä Analyzing results...")

# Load timing results
timing_data = {}
with open(f'{RESULTS_DIR}/timing.txt', 'r') as f:
    for line in f:
        key, value = line.strip().split(',')
        timing_data[key] = float(value)

seq_time = timing_data['sequential_ms']
par_time = timing_data['parallel_ms']
speedup = timing_data['speedup']
threads = int(timing_data['threads'])

print(f"\n{'='*70}")
print("OPENMP PERFORMANCE RESULTS")
print(f"{'='*70}")
print(f"\nSequential Time:  {seq_time:.0f} ms")
print(f"Parallel Time:    {par_time:.0f} ms ({threads} threads)")
print(f"Speedup:          {speedup:.2f}x")
print(f"Efficiency:       {(speedup/threads)*100:.1f}%")

# Load EKF outputs
channel1_ekf = pd.read_csv(f'{RESULTS_DIR}/channel1_ekf.csv').values
channel2_ekf = pd.read_csv(f'{RESULTS_DIR}/channel2_ekf.csv').values
channel3_ekf = pd.read_csv(f'{RESULTS_DIR}/channel3_ekf.csv').values

# Load ground truth
ground_truth = pd.read_csv(f'{DATA_DIR}/ground_truth_15min.csv')[['x', 'y', 'z']].values

# Calculate errors
errors1 = np.linalg.norm(channel1_ekf - ground_truth, axis=1)
errors2 = np.linalg.norm(channel2_ekf - ground_truth, axis=1)
errors3 = np.linalg.norm(channel3_ekf - ground_truth, axis=1)

print(f"\nEKF Errors:")
print(f"  Channel 1 (IMU): {np.mean(errors1):.4f} m")
print(f"  Channel 2 (GPS): {np.mean(errors2):.4f} m")
print(f"  Channel 3 (Mag): {np.mean(errors3):.4f} m")

# ============================================================================
# VISUALIZE
# ============================================================================

print("\nüìä Creating visualization...")

fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# Plot 1: Speedup
ax1 = axes[0, 0]
configs = ['Sequential', f'Parallel\n({threads} threads)']
times = [seq_time, par_time]
colors = ['red', 'green']
bars = ax1.bar(configs, times, color=colors, alpha=0.7, edgecolor='black', linewidth=2)
for bar, time in zip(bars, times):
    ax1.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 50,
            f'{time:.0f} ms', ha='center', fontweight='bold')
ax1.set_ylabel('Processing Time (ms)', fontweight='bold')
ax1.set_title(f'OpenMP Speedup: {speedup:.2f}x', fontweight='bold')
ax1.grid(True, alpha=0.3, axis='y')

# Plot 2: Efficiency
ax2 = axes[0, 1]
efficiency = (speedup / threads) * 100
ideal = 100
ax2.bar(['Actual', 'Ideal'], [efficiency, ideal],
       color=['orange', 'lightblue'], alpha=0.7, edgecolor='black', linewidth=2)
ax2.set_ylabel('Efficiency (%)', fontweight='bold')
ax2.set_title('Parallel Efficiency', fontweight='bold')
ax2.set_ylim([0, 110])
ax2.grid(True, alpha=0.3, axis='y')
ax2.text(0, efficiency + 3, f'{efficiency:.1f}%', ha='center', fontweight='bold')
ax2.text(1, ideal + 3, f'{ideal:.0f}%', ha='center', fontweight='bold')

# Plot 3: Error comparison
ax3 = axes[1, 0]
channel_names = ['IMU', 'GPS', 'Mag']
mean_errors = [np.mean(errors1), np.mean(errors2), np.mean(errors3)]
ax3.bar(channel_names, mean_errors, color=['red', 'green', 'blue'],
       alpha=0.7, edgecolor='black', linewidth=2)
ax3.set_ylabel('Mean Error (m)', fontweight='bold')
ax3.set_title('EKF Error by Channel', fontweight='bold')
ax3.grid(True, alpha=0.3, axis='y')

# Plot 4: Summary
ax4 = axes[1, 1]
ax4.axis('off')
summary = f"""
DAY 3 SUMMARY
{'='*40}

OpenMP Performance:
  Threads:       {threads}
  Sequential:    {seq_time:.0f} ms
  Parallel:      {par_time:.0f} ms
  Speedup:       {speedup:.2f}x
  Efficiency:    {efficiency:.1f}%

EKF Accuracy:
  IMU mean:      {np.mean(errors1):.4f} m
  GPS mean:      {np.mean(errors2):.4f} m
  Mag mean:      {np.mean(errors3):.4f} m

Implementation:
  Language:      C++ with Eigen
  Parallelism:   OpenMP sections
  Channels:      3 independent EKFs
  State dim:     6 (pos + vel)
"""
ax4.text(0.1, 0.5, summary, fontsize=11, family='monospace', verticalalignment='center')

plt.suptitle('Day 3: C++ EKF with OpenMP Parallelization', fontsize=15, fontweight='bold')
plt.tight_layout()

viz_path = f'{RESULTS_DIR}/day3_openmp_results.png'
plt.savefig(viz_path, dpi=300, bbox_inches='tight')
plt.show()

print(f"‚úÖ Visualization saved: {viz_path}")

# ============================================================================
# SAVE RESULTS
# ============================================================================

import json

results = {
    'sequential_time_ms': seq_time,
    'parallel_time_ms': par_time,
    'speedup': speedup,
    'threads': threads,
    'efficiency_pct': efficiency,
    'errors': {
        'channel1_mean': float(np.mean(errors1)),
        'channel2_mean': float(np.mean(errors2)),
        'channel3_mean': float(np.mean(errors3))
    }
}

json_path = f'{RESULTS_DIR}/day3_results.json'
with open(json_path, 'w') as f:
    json.dump(results, f, indent=2)

print(f"‚úÖ Results saved: {json_path}")

# ============================================================================
# SUMMARY
# ============================================================================

print("\n" + "="*70)
print("‚úÖ DAY 3 COMPLETE")
print("="*70)
print(f"\nKey Results:")
print(f"  ‚ö° OpenMP speedup: {speedup:.2f}x with {threads} threads")
print(f"  üìâ Processing: {seq_time:.0f}ms ‚Üí {par_time:.0f}ms")
print(f"  üìä Efficiency: {efficiency:.1f}%")
print(f"\nReady for Day 4: FFNN bias correction + GPU acceleration")
print("="*70)